https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa
https://velog.io/@sweetykr/42Seoul-Webserv
https://medium.com/@mjbaldwin/linux-webserver-cheatsheet-7440b1264f8
https://forhjy.medium.com/42-webserv-cgi-programming-66d63c3b22db
https://github.com/Dungyichao/http_server
https://www.google.com/search?q=webserve+cpp&oq=webserve+cpp&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTILCAEQABgNGBMYgAQyDAgCEAAYChgTGBYYHjIOCAMQABgIGAoYDRgTGB4yDggEEAAYChgPGBMYFhgeMgYIBRBFGDzSAQg2NjUzajBqN6gCALACAA&sourceid=chrome&ie=UTF-8#fpstate=ive&vld=cid:ebe2fb0a,vid:VlUO6ERf1TQ
https://www.tutorialspoint.com/cplusplus/cpp_web_programming.htm
https://www.tutorialspoint.com/cplusplus/cpp_web_programming.htm
https://osasazamegbe.medium.com/showing-building-an-http-server-from-scratch-in-c-2da7c0db6cb7
https://beej.us/guide/bgnet/
https://www.freecodecamp.org/news/the-nginx-handbook/
https://www.youtube.com/playlist?list=PL9IEJIKnBJjH_zM5LnovnoaKlXML5qh17
https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
https://learn.microsoft.com/en-us/previous-versions/exchange-server/exchange-10/ms526508(v=exchg.10)?redirectedfrom=MSDN
https://learn.microsoft.com/en-us/previous-versions/exchange-server/exchange-10/ms527550(v=exchg.10)?redirectedfrom=MSDN
------------------------------------------------------------------------------------------------------------------------------------------------
Read the Configuration File:
Parse the configuration file to retrieve the server settings such as port, host, server names, default error pages, etc.

Set Up the Server:
Create a socket using the socket() function.
Bind the socket to the specified host and port using bind().
Set the socket to listen for incoming connections using listen().

Accept Incoming Connections:
Use select(), poll(), or an equivalent function to monitor the listening socket for incoming connections.
Accept incoming connections using accept() when a new connection is detected.
Add the accepted connection to the list of connections to monitor.

Handle Client Requests:
Read the incoming data from the client connection using read() or recv().
Parse the received data according to the HTTP protocol to extract the request method, headers, and body.
Extract the requested URI and any query parameters from the request.
Based on the configuration and routing rules, determine how to handle the request.

Serve Static Files:
If the request is for a static file, determine the corresponding file path on the server.
Check if the file exists and is accessible.
Read the file contents into memory.
Generate appropriate response headers, including content type and content length.
Write the response headers and file contents to the client connection using write() or send().

Handle CGI Execution:
If the request requires CGI execution, extract the requested URI and the corresponding CGI script path.
Execute the CGI script, passing the requested file as an argument.
Capture the output of the CGI script and send it as the response body.
Set appropriate response headers, including content type and content length.
Handle chunked requests and responses if necessary.

Handle Error Cases:
Implement default error pages for different HTTP status codes.
Handle errors gracefully and send appropriate error responses when necessary.

Monitor Connections:
Continuously monitor all active connections using select(), poll(), or an equivalent function.
Handle read and write events for each connection.
Read data from the client connection, parse requests, and generate appropriate responses.
Write response data to the client connection.

Test and Validate:
Use tools like telnet, web browsers, or automated testing frameworks to validate the server's behavior.
Compare the server's behavior with NGINX or other HTTP servers to ensure compatibility.
Write unit tests and integration tests to verify the functionality of each component.

Optimize and Refactor:
Identify bottlenecks or performance issues in the server's implementation.
Optimize critical sections or algorithms to improve performance.
Refactor code to improve readability, modularity, and maintainability.
------------------------------------------------------------------------------------------------------------------------------------------------
struct sockaddr_in {
    short sin_family;          // Address family (e.g., AF_INET)
    u_short sin_port;          // Port number in network byte order
    struct in_addr sin_addr;   // IP address in network byte order
    char sin_zero[8];          // Padding to ensure structure size consistency
};
sin_family: Specifies the address family, typically set to AF_INET for IPv4 addresses.
sin_port: Represents the port number associated with the address. It should be specified using the htons() function to ensure correct byte order in network representation.
sin_addr: Holds the IP address itself, represented by the struct in_addr data structure. The IP address should be set using functions like inet_addr() or inet_pton().
sin_zero: Padding field to ensure the structure size consistency. It is typically set to all zeros.
When using the struct sockaddr_in, you need to populate its members appropriately before using it with socket-related functions. For example, when binding a socket to a specific IP address and port, you would set the sin_family, sin_port, and sin_addr fields accordingly.
Note that the inet_addr() function is used to convert the IP address from the string format to the appropriate network byte order representation.
The struct sockaddr_in is commonly used in socket programming for representing IPv4 addresses in network-related operations, such as binding a socket, connecting to a remote server, or accepting incoming connections.
------------------------------------------------------------------------------------------------------------------------------------------------
127.0.0.1:8080/src
127.0.0.1:6969/src

header:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ======> header : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ====> 